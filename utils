#!/usr/bin/env bash

# Author: Santhosh Siva
# Date Created: 03-08-2025

# Colors
BLUE=$(tput setaf 4)
PROMPT=$(tput setaf 3)
GREEN=$(tput setaf 2)
RED=$(tput setaf 1)
NC=$(tput sgr0)

overwrite() { echo -e "\r\033[1A\033[0K$@"; }

default_spaces="    "

print_message() {
	local number=$2
	local message=$1

	if [ -z "$message" ]; then
		message=""
	fi

	if [ -z "$number" ]; then
		number=0
	fi

	if [ "$number" -eq 0 ]; then
		echo -e "   $message"
		return 0
	fi

	# print_message ""

	if [ "$number" -lt 10 ]; then
		printf "%d. %s\n" "$number" "$message"
		return 0
	fi

	printf "%02d. %s\n" "$number" "$message"
}

indent() {
	local prefix="   â”‚ "
	sed "s/^/${prefix}/"
}

install_dependency() {
	local cmd=$1
	local package=$2

	if ! command -v "$cmd" >/dev/null; then
		if brew install "$package" >>"$log_file" 2>>"$error_log_file"; then
			return
		else
			print_message "${RED}Failed to install $package.${NC}"
			exit 1
		fi
	fi
}

validate_dependencies() {
	for cmd in $@; do
		install_dependency "$cmd" "$cmd"
	done
}

print_banner() {
	print_message ""
	figlet -f slant "Gitsy" | lolcat
	print_message ""
}

prompt_user() {
	local default_to_yes=$1
	local message=$2
	local step_number=$3

	if [ -n "$step_number" ] && [ "$step_number" -ne 0 ]; then
		local prefix="$(printf "%${default_spaces}s")${step_number}. "
	elif [ "$step_number" -eq 0 ]; then
		local prefix="$(printf "%${default_spaces}s")   "
	else
		local prefix="$(printf "%${default_spaces}s")- "
	fi

	local prompt="${prefix}${PROMPT}${message}${NC} "

	if [ "$default_to_yes" = "true" ]; then
		read -p "${prompt}(Y/n): " response
		response="${response:-y}"
	else
		read -p "${prompt}(y/N): " response
		response="${response:-n}"
	fi

	case "$response" in
	[Yy]) echo "y" ;;
	[Nn]) echo "n" ;;
	*) print_message "Invalid input." 0 && exit 1 ;;
	esac
}

fetch_current_branch() {
	current_branch=$(git rev-parse --abbrev-ref HEAD)
	if [ -z "$current_branch" ]; then
		print_message "${RED}Failed to get current branch. [Fail]${NC}"
		exit 1
	fi
	echo "${current_branch}"
}

stash_changes() {
	local stash_changes=$1
	local step_number=$2
	local tag_name=$3

	if [ -z "$step_number" ]; then
		step_number=0
	fi

	if [ "$stash_changes" = "true" ]; then
		print_message "${BLUE}Stashing changes...${NC}" $step_number

		if ! (git add -A 2>&1 | indent); then
			print_message "${RED}Failed to add changes to stash. [Fail]${NC}" 0
			exit 1
		fi

		local stash_message
		if [ -n "$tag_name" ]; then
			stash_message="manual_stash__tag_${tag_name}__date_$(date '+%Y-%m-%d/%H:%M:%S')"
		else
			stash_message="auto_stash__date_$(date '+%Y-%m-%d/%H:%M:%S')"
		fi

		if ! (git stash push -m "$stash_message" 2>&1 | indent 4); then
			print_message "${RED}Failed to stash changes. [Fail]${NC}" 0
			exit 1
		fi

		print_message "${GREEN}Changes stashed successfully.${NC}" 0
	fi
}

fetch_changes() {
	local target_branch=$1

	if [ -z "$target_branch" ]; then
		print_message "${RED}Target branch is not set. [Fail]${NC}" 0
		return 1
	fi

	if ! git fetch origin "${target_branch}:${target_branch}" 2>&1 | indent; then
		print_message "${PROMPT}Auto-Fetch failed, Please do it manually.${NC}"
		return 1
	else
		return 0
	fi

	return 0
}

checkout_branch() {
	local target_branch=$1
	local new_branch=$2

	if [ -z "$target_branch" ]; then
		print_message "${RED}Target branch is not set. [Fail]${NC}"
		exit 1
	fi

	if [ "$new_branch" = "true" ]; then
		if ! git checkout -b "${target_branch}" 2>&1 | indent; then
			print_message "${RED}Failed to create new branch. [Fail]${NC}"
			exit 1
		fi
		print_message "${GREEN}Created new local branch ${NC}${target_branch}${GREEN}. [DONE]${NC}"
		return 0
	fi

	if ! git checkout "${target_branch}" 2>&1 | indent; then
		print_message "${RED}Failed to checkout to branch ${NC}${target_branch}${RED}. [Fail]${NC}"
		exit 1
	fi
	return 0
}

create_worktree() {
	local target_branch="$1"
	local worktree_path="$2"
	local new_branch="$3"
	local base_branch
	local created_worktree_message="${GREEN}Successfully created worktree for branch ${NC}$target_branch${GREEN} at ${NC}$worktree_path${GREEN}. [DONE]${NC}"
	local failed_worktree_message="${RED}Failed to create worktree for branch ${NC}$target_branch${RED}. [Fail]${NC}"

	if [ -z "$target_branch" ]; then
		print_message "${RED}Target branch is not set. [Fail]${NC}"
		exit 1
	fi
	if [ -z "$worktree_path" ]; then
		print_message "${RED}Worktree path is not set. [Fail]${NC}"
		exit 1
	fi
	if [ -d "$worktree_path" ]; then
		print_message "${RED}Worktree path already exists. [Fail]${NC}"
		exit 1
	fi

	base_branch=$(fetch_current_branch)
	if [ -z "$base_branch" ]; then
		print_message "${RED}Failed to get current branch. [Fail]${NC}"
		exit 1
	fi

	if [ "$new_branch" = "true" ]; then
		# Make sure the source branch exists remotely!
		if ! git rev-parse --verify "origin/$base_branch" >/dev/null 2>&1; then
			print_message "${RED}Base branch ${NC}origin/$base_branch${RED} not found. Cannot create new branch.${NC}"
			exit 1
		fi

		# Use the -b flag on worktree directly:
		if ! git worktree add -b "$target_branch" "$worktree_path" "origin/$base_branch" 2>&1 | indent; then
			print_message "${failed_worktree_message}"
			exit 1
		fi

		print_message "${BLUE}Pushing new branch ${NC}$target_branch${BLUE} to remote...${NC}"
		if ! git push -u origin "$target_branch" 2>&1 | indent; then
			print_message "${RED}Failed to push new branch ${NC}$target_branch${RED} to remote. [Fail]${NC}"
			exit 1
		fi

		print_message "${created_worktree_message}"
		return 0
	fi

	# Just add the worktree to an existing branch:
	if ! git worktree add "$worktree_path" "$target_branch" 2>&1 | indent; then
		print_message "${failed_worktree_message}"
		exit 1
	fi

	print_message "${created_worktree_message}"
	return 0
}

reset_to_target_branch() {
	local target_branch=$1

	if [ -z "$target_branch" ]; then
		print_message "${RED}Target branch is not set. [Fail]${NC}"
		exit 1
	fi

	print_message "${BLUE}Resetting to ${NC}origin/${target_branch}${BLUE}...${NC}"

	if ! git reset --hard "origin/${target_branch}" 2>&1 | indent; then
		print_message "${RED}Failed to reset to ${NC}origin/${target_branch}${RED}. [Fail]${NC}"
		exit 1
	fi

	print_message "${GREEN}Reset to ${NC}origin/${target_branch}${GREEN} successfully.${NC}"
}

pull_changes() {
	local target_branch=$1
	local step_number=$2

	if [ -z "$step_number" ]; then
		step_number=0
	fi

	if [ -z "$target_branch" ]; then
		print_message "${RED}Target branch is not set. [Fail]${NC}"
		exit 1
	fi

	print_message "${BLUE}Pulling changes from ${NC}remote/${target_branch}${BLUE}...${NC}" $step_number
	if ! git pull origin "${target_branch}" 2>&1 | indent; then
		print_message "${RED}Failed to pull changes from remote. [Fail]${NC}"
		exit 1
	fi
	print_message "${GREEN}Pulled changes from ${NC}remote/${target_branch} ${GREEN}successfully.${NC}"
}

push_changes() {
	local target_branch=$1
	local should_force_push=$2
	local step_number=$3

	if [ -z "$step_number" ]; then
		step_number=0
	fi

	if [ -z "$target_branch" ]; then
		print_message "${RED}Target branch is not set. [Fail]${NC}"
		exit 1
	fi

	if [ "$should_force_push" = "true" ]; then
		print_message "${BLUE}Force pushing changes to ${NC}remote/${target_branch}${BLUE}...${NC}" $step_number
		if ! git push --force origin "${target_branch}" 2>&1 | indent; then
			print_message "${RED}Failed to force push changes to remote. [Fail]${NC}"
			exit 1
		fi
	else
		print_message "${BLUE}Pushing changes to ${NC}remote/${target_branch}${BLUE}...${NC}" $step_number
		if ! git push origin "${target_branch}" 2>&1 | indent; then
			print_message "${RED}Failed to push changes to remote. [Fail]${NC}"
			exit 1
		fi
	fi
	print_message "${GREEN}Pushed changes to ${NC}remote/${target_branch} ${GREEN}successfully.${NC}"
}

already_on_branch() {
	local target_branch=$1
	print_message "${BLUE}Checking current branch...${NC}" 1
	current_branch=$(fetch_current_branch true)
	if [ "${target_branch}" = "${current_branch}" ]; then
		print_message "${GREEN}Already on branch ${NC}${target_branch}${GREEN}. [DONE]${NC}"
		exit 1
	fi
}

check_if_target_branch_is_set() {
	local target_branch=$1
	if [ -z "${target_branch}" ]; then
		print_message "${RED}Error: No target branch specified, use -t or --target-branch option.${NC}"
		exit 1
	fi
}
