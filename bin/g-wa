#!/usr/bin/env bash

# Author: Santhosh Siva
# Date Created: 03-08-2025

# Description:
# This script creates a new git worktree for a specified branch.
# If the branch does not exist, it prompts the user to create it.

# Resolve script directory (works with symlinks for npm global install)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
	DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
	SOURCE="$(readlink "$SOURCE")"
	[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
source "$SCRIPT_DIR/utils"

# Default Values
stash=false
target_branch=

set_flags() {
	while [ $# -gt 0 ]; do
		case "$1" in
		-h | --help)
			echo "g-wa - create git worktree for branch"
			echo " "
			echo "g-wa [options]"
			echo " "
			echo "options:"
			echo "-h, --help                                                             show brief help"
			echo "--target-branch BRANCH, --target-branch=BRANCH, -t=BRANCH, -t BRANCH   specify the target branch"
			echo "--stash-changes                                                        stash changes before proceeding"
			exit 0
			;;
		-t=* | --target-branch=*)
			target_branch="${1#*=}"
			if [ -z "$target_branch" ]; then
				echo ""
				echo "${RED}Error: No target branch specified.$NC"
				exit 1
			fi
			;;
		-t | --target-branch)
			shift
			if [ $# -gt 0 ]; then
				target_branch="$1"
			else
				echo ""
				echo "${RED}Error: No target branch specified.$NC"
				exit 1
			fi
			;;
		-s | --stash-changes)
			stash=true
			;;
		*)
			echo "${RED}Unknown option:${NC} $1"
			exit
			;;
		esac
		shift
	done
}

try_fetching_branch() {
	fetch_success=$(fetch_changes "${target_branch}")
	if [ "${fetch_success}" = "false" ]; then
		print_message "" -1
		print_message "${RED}Failed to fetch changes for branch ${target_branch}. [Fail]${NC}" -1
		exit 1
	fi
}

check_branch_in_worktree() {
	local branch=$1
	local step_number=$2

	print_message "${BLUE}Checking if branch exists in worktrees...${NC}" $step_number

	# Check if branch is already checked out in another worktree
	local existing_worktree=$(git worktree list | grep "\[${branch}\]" | awk '{print $1}')
	if [ -n "$existing_worktree" ]; then
		print_message "${RED}Branch ${NC}${branch}${RED} is already checked out in worktree:${NC}"
		print_message "${GREEN}${existing_worktree}${NC}"
		print_message "${BLUE}Navigate to it with:${NC} ${GREEN}cd ${existing_worktree}${NC}"
		exit 0
	fi
}

generate_worktree_path() {
	local target_branch=$1
	local step_number=$2

	# Determine worktree directory based on current location
	local worktree_dir
	local current_dir=$(basename "$PWD")
	local parent_dir=$(basename "$(dirname "$PWD")")

	# Check if we're already in a worktree (parent directory contains worktrees)
	if [ "$parent_dir" = "worktrees" ]; then
		# We're in a worktree, use parent of parent for new worktrees
		worktree_dir="../"
	else
		# We're in main repo, create worktrees subdirectory
		if [ ! -d "../worktrees" ]; then
			mkdir ../worktrees
		fi
		worktree_dir="../worktrees/"
	fi

	# Sanitize branch name for worktree directory
	local worktree_name=$(sanitize_branch_name "$target_branch")
	local path="${worktree_dir}${worktree_name}"

	# Convert to absolute path
	path=$(cd "$(dirname "$path")" 2>/dev/null && echo "$(pwd)/$(basename "$path")")

	# If path exists, generate a unique path
	if [ -d "$path" ]; then
		print_message "${RED}Worktree path already exists. [Fail]${NC}"
		no_of_identical_dirs=$(find "$(dirname "$path")" -maxdepth 1 -type d -name "${worktree_name}*" 2>/dev/null | wc -l)
		path="$(dirname "$path")/${worktree_name}_$(($no_of_identical_dirs + 1))"
		print_message "${BLUE}Using new path: ${NC}${path}${NC}"
	fi

	# Return the generated path
	echo "$path"
}

checkout_or_create_branch() {
	local step_number=$1

	# Check if branch is already in a worktree
	check_branch_in_worktree "${target_branch}" $step_number

	# Generate worktree path
	local path=$(generate_worktree_path "${target_branch}" $step_number)

	# Check if branch exists locally
	if git show-ref --verify --quiet "refs/heads/${target_branch}"; then
		try_fetching_branch
		print_message "${BLUE}Creating worktree for branch ${NC}${target_branch}${BLUE} at ${NC}${path}${NC}" $((step_number + 1))
		create_worktree "${target_branch}" "${path}"
		return
	fi

	print_message "${RED}Branch not found locally.${NC}"
	print_message "${BLUE}Checking if branch exists on remote...${NC}" $((step_number + 1))

	if git ls-remote --heads origin "${target_branch}" | grep -q "${target_branch}"; then
		print_message "${GREEN}Branch available on remote.${NC}"
		try_fetching_branch
		print_message "${BLUE}Creating worktree for branch ${NC}${target_branch}${BLUE} at ${NC}${path}${NC}" $((step_number + 2))
		create_worktree "${target_branch}" "${path}"
		return
	fi

	print_message "${RED}Branch not found on remote.${NC}"

	create_new_branch=$(prompt_user true "Create new branch?" $((step_number + 2)))
	if [ "${create_new_branch}" = "y" ]; then
		print_message "${BLUE}Creating worktree for branch ${NC}${target_branch}${BLUE} at ${NC}${path}${NC}" $((step_number + 3))
		create_worktree "${target_branch}" "${path}" true
		return
	fi

	print_message "" -1
	print_message "${RED}Aborted.${NC}" -1
	exit 1
}

prompt_restructure_confirmation() {
	local git_root=$1
	local repo_name=$2
	local default_branch=$3
	local step_number=$4

	# Save the current branch before restructuring
	local original_branch=$(get_current_branch)
	if [ -z "$original_branch" ]; then
		print_message "" -1
		print_message "${RED}Failed to get current branch. [Fail]${NC}" -1
		exit 1
	fi
	print_message "${step_number}. ${BLUE}Repository Reorganization Required${NC}" -1 >&2
	print_message "Your repository will be moved into a 'main' subdirectory to enable worktree support" 0 >&2
	print_message "" 0 >&2
	print_message "Current location: ${BLUE}${git_root}${NC}" 0 >&2
	print_message "New location:     ${BLUE}${git_root}/main${NC}" 0 >&2
	print_message "Current branch:   ${BLUE}${original_branch}${NC}" 0 >&2
	print_message "" 0 >&2
	print_message "This structure allows you to work on multiple branches simultaneously" 0 >&2
	print_message "by creating worktrees in separate directories" 0 >&2

	# If not on default branch, mention worktree will be created
	if [ "$original_branch" != "$default_branch" ]; then
		local sanitized_name=$(sanitize_branch_name "$original_branch")
		print_message "" 0 >&2
		print_message "Note: You're currently on ${BLUE}${original_branch}${NC} (not ${BLUE}${default_branch}${NC})" 0 >&2
		print_message "Two directories will be created:" 0 >&2
		print_message "" 0 >&2
		print_message "• ${BLUE}${repo_name}/main${NC} → ${BLUE}${default_branch}${NC} branch" 0 >&2
		print_message "• ${BLUE}${repo_name}/worktrees/${sanitized_name}${NC} → ${BLUE}${original_branch}${NC} branch" 0 >&2
	fi

	# Prompt user for confirmation
	local proceed=$(prompt_user false "Proceed with restructuring?" "$step_number")
	if [ "$proceed" != "y" ]; then
		print_message "" -1 >&2
		print_message "${RED}Restructuring cancelled by user.${NC}" -1 >&2
		exit 1
	fi
}

create_main_dir() {
	local git_root=$1
	local temp_dir=$2
	local step_number=$3

	# Create temp directory and move everything there
	if ! mkdir -p "$temp_dir"; then
		print_message "" -1 >&2
		print_message "${RED}Failed to create temporary directory. [Fail]${NC}" -1 >&2
		exit 1
	fi

	print_message "${BLUE}Moving repository contents to temporary location...${NC}" $step_number >&2
	if ! (shopt -s dotglob && mv "$git_root"/* "$temp_dir/" 2>&1); then
		print_message "" -1 >&2
		print_message "${RED}Failed to move contents to temporary directory. [Fail]${NC}" -1 >&2
		rm -rf "$temp_dir"
		exit 1
	fi

	# Create main directory
	local main_dir="${git_root}/main"
	if ! mkdir -p "$main_dir"; then
		print_message "" -1 >&2
		print_message "${RED}Failed to create main directory. [Fail]${NC}" -1 >&2
		# Restore from temp
		(shopt -s dotglob && mv "$temp_dir"/* "$git_root/")
		rm -rf "$temp_dir"
		exit 1
	fi

	# Move everything from temp to main
	if ! (shopt -s dotglob && mv "$temp_dir"/* "$main_dir/" 2>&1); then
		print_message "" -1 >&2
		print_message "${RED}Failed to move contents to main directory. [Fail]${NC}" -1 >&2
		exit 1
	fi

	# Clean up temp directory
	rm -rf "$temp_dir"

	echo "$main_dir"
}

checkout_main_in_main_branch() {
	local repo_name=$1
	local main_dir=$2
	local default_branch=$3
	local step_number=$4

	# Checkout the default branch into main
	print_message "${BLUE}Checking out branch ${NC}${default_branch}${BLUE} into main directory...${NC}" $step_number
	if ! git -c color.ui=always checkout "$default_branch" 2>&1 | indent; then
		print_message "" -1
		print_message "${RED}Failed to checkout ${NC}${default_branch}${RED} branch. [Fail]${NC}" -1
		exit 1
	fi

	print_message "${GREEN}Repository restructured successfully to ${NC}${repo_name}/main/${GREEN}. [DONE]${NC}"
}

should_trigger_from_default_branch() {
	local default_branch=$1
	local original_branch=$2

	if [ "$original_branch" != "$default_branch" ]; then
		print_message "" -1
		print_message "${RED}Warning: We only support creating worktrees from the default branch.${NC}" -1
		print_message "${RED}Commit or stash changes, checkout to ${NC}${default_branch}${RED}, and try again.${NC}" -1
		exit 1
	fi
}

create_main_dir_if_necessary() {
	local default_branch=$1
	local step_number=$2

	if [ -z "$step_number" ]; then
		step_number=0
	fi

	local git_root=$(git rev-parse --show-toplevel)
	local current_dir=$(basename "$git_root")
	local parent_dir=$(basename "$(dirname "$git_root")")
	local repo_name=$(get_repo_name)

	# Check if already in correct structure (repo_name/main/.git)
	if [ "$current_dir" = "main" ] && [ "$parent_dir" = "$repo_name" ]; then
		return 0
	fi

	# Prompt user for restructuring
	prompt_restructure_confirmation "$git_root" "$repo_name" "$default_branch" "$step_number"
	local prompt_exit_code=$?
	if [ $prompt_exit_code -ne 0 ]; then
		exit $prompt_exit_code
	fi

	# Get parent directory path
	local parent_path=$(dirname "$git_root")
	local temp_dir="${parent_path}/.temp-${repo_name}-$$"

	# Create main directory and restructure
	local main_dir=$(create_main_dir "$git_root" "$temp_dir" $((step_number + 1)))

	# Navigate to main directory using direct path
	if ! navigate_to_dir "$main_dir"; then
		print_message "" -1
		print_message "${RED}Failed to navigate to main directory. [Fail]${NC}" -1
		exit 1
	fi

	# Checkout the default branch into main directory
	checkout_main_in_main_branch "$repo_name" "$main_dir" "$default_branch" $((step_number + 2))
}

create_target_dir_if_necessary() {
	# Generate worktree path
	local path=$(generate_worktree_path "${target_branch}" $step_number)

	# Check if branch exists locally
	if git show-ref --verify --quiet "refs/heads/${target_branch}"; then
		try_fetching_branch
		create_worktree "${target_branch}" "${path}"
		return
	fi
}

main() {
	set_flags "$@"
	validate_dependencies git figlet lolcat
	print_banner

	check_if_target_branch_is_set $target_branch

	if ! is_git_repo "$PWD"; then
		print_message "" -1
		print_message "${RED}Not in a git repository. [Fail]${NC}" -1
		exit 1
	fi

	already_on_branch $target_branch 1

	stash_changes $stash 2

	if has_uncommitted_changes "$PWD"; then
		print_message "" -1
		print_message "${RED}Uncommitted changes detected. Commit or stash changes before proceeding. [Fail]${NC}" -1
		exit 1
	fi

	local default_branch=$(get_default_branch)
	local current_branch=$(get_current_branch)

	should_trigger_from_default_branch "$default_branch" "$current_branch"

	local step_number=2
	if [ "$stash" = true ]; then
		step_number=3
	fi

	# Check if we need to restructure (to calculate proper step numbers)
	local git_root=$(git rev-parse --show-toplevel)
	local current_dir=$(basename "$git_root")
	local parent_dir=$(basename "$(dirname "$git_root")")
	local repo_name=$(get_repo_name)
	local needs_restructure=false

	if [ "$current_dir" != "main" ] || [ "$parent_dir" != "$repo_name" ]; then
		needs_restructure=true
	fi

	create_main_dir_if_necessary "$default_branch" $step_number

	# Calculate next step number
	local next_step=$((step_number + 1))
	if [ "$needs_restructure" = true ]; then
		# Restructuring uses 3 steps: prompt, move, checkout
		next_step=$((step_number + 3))
	fi

	checkout_or_create_branch $next_step
}

main "$@"
exit 0
